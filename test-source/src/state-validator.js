// Generated by CoffeeScript 1.10.0
define(['underscore', 'galileo-lib/modules/managers/error-manager'], function(_, errorManager) {
  var StateValidator;
  StateValidator = (function() {
    function StateValidator() {}

    StateValidator.prototype.ALIASES = {
      PROTO_LAYOUTS: [['feature', 'border']]
    };

    StateValidator.prototype._getProtoLayoutAliases = function(name) {
      return _(this.ALIASES.PROTO_LAYOUTS).find(function(aliases) {
        return _(aliases).contains(name);
      });
    };

    StateValidator.prototype._bootstrap = function() {
      return {
        columns: [],
        name: 'Bootstrap-Block-0000000000000',
        type: 'email-block',
        protoLayout: 'singlerow'
      };
    };

    StateValidator.prototype._validateObject = function(s) {
      return _(s).isObject();
    };

    StateValidator.prototype._validateKeys = function(s) {
      var requiredAttributes;
      requiredAttributes = ['columns', 'name', 'type', 'protoLayout'];
      return requiredAttributes.every(function(attr) {
        return _.has(s, attr);
      });
    };

    StateValidator.prototype._validateColumns = function(s) {
      return _(s.columns).isArray();
    };

    StateValidator.prototype.filteredState = function(state) {
      var key;
      for (key in state) {
        if (key !== '_galileo') {
          delete state[key];
        }
      }
      return _.extend(state, this._bootstrap());
    };

    StateValidator.prototype.updatePrototypeLayoutAlias = function(prototypeMarkupService, state) {
      var aliases;
      aliases = this._getProtoLayoutAliases(state.protoLayout);
      if (aliases == null) {
        return;
      }
      return state.protoLayout = prototypeMarkupService.getCurrentPrototypeLayoutAlias(aliases);
    };

    StateValidator.prototype.isValid = function(state) {
      return this._validateObject(state) && this._validateKeys(state) && this._validateColumns(state);
    };


    /*
    Iterate over layout editor state, and make sure there is corresponding content editor state for each block.
    If there is not, remove that content from the layout editor state. Trim the blocks / columns if they
    become empty after this operation. Put the trimmed content in a "stash" in the layout editor state,
    just incase we can restore it again later.
     */

    StateValidator.prototype.removeBlocksWithNoMatchingState = function(state, presentation) {
      var blocksCounter, column, columnCounter, contentCounter, contentSpliced, i, len, missingState, recalculatedColumnWidth, ref, removedBlocks, thisBlock, thisColumn, thisContent;
      removedBlocks = [];
      columnCounter = state.columns.length;
      while (columnCounter--) {
        thisColumn = state.columns[columnCounter];
        blocksCounter = thisColumn.blocks.length;
        while (blocksCounter--) {
          thisBlock = thisColumn.blocks[blocksCounter];
          contentCounter = thisBlock.contents.length;
          while (contentCounter--) {
            thisContent = thisBlock.contents[contentCounter];
            missingState = !presentation.contents[thisContent.name];
            if (missingState) {
              contentSpliced = thisBlock.contents.splice(contentCounter, 1);
              removedBlocks.push({
                content: contentSpliced[0],
                contentIndex: contentCounter,
                blockIndex: blocksCounter,
                columnIndex: columnCounter
              });
              errorManager.error('Missing editor state for CABLE layout block. Removing block.', {
                showErrorMessage: false
              });
            }
          }
          if (!thisBlock.contents.length) {
            thisColumn.blocks.splice(blocksCounter, 1);
          }
        }
        if (!thisColumn.blocks.length) {
          state.columns.splice(columnCounter, 1);
        }
      }
      recalculatedColumnWidth = 100 / state.columns.length;
      ref = state.columns;
      for (i = 0, len = ref.length; i < len; i++) {
        column = ref[i];
        column.width = recalculatedColumnWidth + "%";
      }
      if (removedBlocks.length) {
        return state.stash.push(removedBlocks);
      }
    };

    return StateValidator;

  })();
  return new StateValidator;
});
